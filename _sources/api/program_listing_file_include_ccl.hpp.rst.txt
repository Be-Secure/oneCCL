
.. _program_listing_file_include_ccl.hpp:

Program Listing for File ccl.hpp
================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_ccl.hpp>` (``include\ccl.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <memory>
   #include <ostream>
   
   #include "ccl_types.hpp"
   #include "ccl_type_traits.hpp"
   
   class ccl_comm;
   class ccl_stream;
   
   namespace ccl
   {
   
   class communicator;
   class stream;
   struct communicator_interface;
   
   struct host_attr_impl;
   class ccl_host_attr;
   
   #ifdef MULTI_GPU_SUPPORT
   struct gpu_comm_attr;
   class comm_group;
   struct device_attr_impl;
   class ccl_device_attr;
   #endif
   
   using communicator_t = std::unique_ptr<ccl::communicator>;
   using shared_communicator_t = std::shared_ptr<ccl::communicator>;
   
   using stream_t = std::unique_ptr<ccl::stream>;
   
   class ccl_host_attr
   {
   public:
       friend class ccl_device_attr;
       friend struct communicator_interface_dispatcher;
       friend class environment;
   
       virtual ~ccl_host_attr() noexcept;
   
       template<ccl_host_attributes attrId,
                class Value,
                class = typename std::enable_if<is_attribute_value_supported<attrId, Value>()>::type>
       Value set_value(const Value& v);
   
       template<ccl_host_attributes attrId>
       const typename ccl_host_attributes_traits<attrId>::type& get_value() const;
   
   protected:
       ccl_host_attr(const ccl_host_attr& src);
   
   private:
       ccl_host_attr(const ccl_version_t& library_version,
                     const ccl_host_comm_attr_t &core = ccl_host_comm_attr_t(),
                     ccl_version_t api_version = ccl_version_t {CCL_MAJOR_VERSION,
                                                                CCL_MINOR_VERSION,
                                                                CCL_UPDATE_VERSION,
                                                                CCL_PRODUCT_STATUS,
                                                                CCL_PRODUCT_BUILD_DATE,
                                                                CCL_PRODUCT_FULL});
   
       std::unique_ptr<host_attr_impl> pimpl;
   };
   
   using comm_attr_t = std::shared_ptr<ccl_host_attr>;
   
   #ifdef MULTI_GPU_SUPPORT
   using comm_group_t = std::shared_ptr<comm_group>;
   class ccl_device_attr : public ccl_host_attr
   {
   public:
       friend class comm_group;
       friend struct communicator_interface_dispatcher;
   
       using base_t = ccl_host_attr;
       ~ccl_device_attr() noexcept;
   
       template<ccl_device_attributes attrId,
                class Value,
                class = typename std::enable_if<std::is_same<typename ccl_device_attributes_traits<attrId>::type, Value>::value>::type>
       Value set_value(Value&& v);
   
       template<ccl_device_attributes attrId>
       const typename ccl_device_attributes_traits<attrId>::type& get_value() const;
   
   private:
       ccl_device_attr(const ccl_host_attr& src);
       std::unique_ptr<device_attr_impl> pimpl;
   };
   
   using device_comm_attr_t = std::shared_ptr<ccl_device_attr>;
   #endif //MULTI_GPU_SUPPORT
   
   class environment
   {
   public:
       ~environment();
   
       static environment& instance();
   
       void set_resize_fn(ccl_resize_fn_t callback);
   
       communicator_t create_communicator(const ccl::comm_attr_t& attr = ccl::comm_attr_t()) const;
   
       template<class stream_native_type,
                class = typename std::enable_if<is_stream_supported<stream_native_type>()>::type>
       stream_t create_stream(stream_native_type& native_stream);
   
       stream_t create_stream() const;
   
       ccl_version_t get_version() const;
   
       comm_attr_t create_host_comm_attr(const ccl_host_comm_attr_t& attr = ccl_host_comm_attr_t()) const;
   
   #ifdef MULTI_GPU_SUPPORT
   
       comm_group_t create_comm_group(size_t current_device_group_size,
                                      size_t process_device_group_size,
                                      ccl::shared_communicator_t parent_comm = ccl::shared_communicator_t());
   
   #endif //MULTI_GPU_SUPPORT
   private:
       environment();
   };
   
   class request
   {
   public:
       virtual void wait() = 0;
   
       virtual bool test() = 0;
   
       virtual ~request() = default;
   };
   
   ccl::datatype datatype_create(const ccl::datatype_attr* attr);
   void datatype_free(ccl::datatype dtype);
   size_t datatype_get_size(ccl::datatype dtype);
   
   class stream
   {
   public:
       stream(const stream&) = delete;
       stream& operator=(const stream&) = delete;
   
       stream(stream&&) = default;
       stream& operator=(stream&&) = default;
   
       using impl_t = std::shared_ptr<ccl_stream>;
   private:
       friend class communicator;
       friend class environment;
       stream(impl_t&& impl);
   
       impl_t stream_impl;
   };
   
   class communicator final
   {
   public:
   
       ~communicator();
   
       using coll_request_t = std::unique_ptr<request>;
   
       size_t rank() const;
   
       size_t size() const;
   
   #ifdef MULTI_GPU_SUPPORT
   
       using device_native_reference_t = typename unified_device_type::native_reference_t;
   
       device_native_reference_t get_device();
   
       ccl::device_topology_type get_topology_type() const;
   
       device_comm_attr_t get_device_attr() const;
   #endif
   
       comm_attr_t get_host_attr() const;
       bool is_ready() const;
   
       coll_request_t allgatherv(const void* send_buf, size_t send_count,
                                 void* recv_buf, const size_t* recv_counts,
                                 ccl::datatype dtype,
                                 const ccl::coll_attr* attr = nullptr,
                                 const ccl::stream_t& stream = ccl::stream_t());
   
       template<class buffer_type,
                class = typename std::enable_if<ccl::is_native_type_supported<buffer_type>()>::type>
       coll_request_t allgatherv(const buffer_type* send_buf, size_t send_count,
                                 buffer_type* recv_buf, const size_t* recv_counts,
                                 const ccl::coll_attr* attr = nullptr,
                                 const ccl::stream_t& stream = ccl::stream_t());
       template<class buffer_container_type,
                class = typename std::enable_if<ccl::is_class_supported<buffer_container_type>()>::type>
       coll_request_t allgatherv(const buffer_container_type& send_buf, size_t send_count,
                                 buffer_container_type& recv_buf, const size_t* recv_counts,
                                 const ccl::coll_attr* attr = nullptr,
                                 const ccl::stream_t& stream = ccl::stream_t());
   
       coll_request_t allreduce(const void* send_buf, void* recv_buf,
                                size_t count, ccl::datatype dtype,
                                ccl::reduction reduction,
                                const ccl::coll_attr* attr = nullptr,
                                const ccl::stream_t& stream = ccl::stream_t());
   
       template<class buffer_type,
                class = typename std::enable_if<ccl::is_native_type_supported<buffer_type>()>::type>
       coll_request_t allreduce(const buffer_type* send_buf,
                                buffer_type* recv_buf,
                                size_t count,
                                ccl::reduction reduction,
                                const ccl::coll_attr* attr = nullptr,
                                const ccl::stream_t& stream = ccl::stream_t());
   
       template<class buffer_container_type,
                class = typename std::enable_if<ccl::is_class_supported<buffer_container_type>()>::type>
       coll_request_t allreduce(const buffer_container_type& send_buf,
                                buffer_container_type& recv_buf,
                                size_t count,
                                ccl::reduction reduction,
                                const ccl::coll_attr* attr = nullptr,
                                const ccl::stream_t& stream = ccl::stream_t());
   
       coll_request_t alltoall(const void* send_buf, void* recv_buf,
                               size_t count, ccl::datatype dtype,
                               const ccl::coll_attr* attr = nullptr,
                               const ccl::stream_t& stream = ccl::stream_t());
   
       template<class buffer_type,
           class = typename std::enable_if<ccl::is_native_type_supported<buffer_type>()>::type>
       coll_request_t alltoall(const buffer_type* send_buf,
                               buffer_type* recv_buf,
                               size_t count,
                               const ccl::coll_attr* attr = nullptr,
                               const ccl::stream_t& stream = ccl::stream_t());
   
       template<class buffer_container_type,
           class = typename std::enable_if<ccl::is_class_supported<buffer_container_type>()>::type>
       coll_request_t alltoall(const buffer_container_type& send_buf,
                               buffer_container_type& recv_buf,
                               size_t count,
                               const ccl::coll_attr* attr = nullptr,
                               const ccl::stream_t& stream = ccl::stream_t());
   
       coll_request_t alltoallv(const void* send_buf, const size_t* send_counts,
                                void* recv_buf, const size_t* recv_counts,
                                ccl::datatype dtype,
                                const ccl::coll_attr* attr = nullptr,
                                const ccl::stream_t& stream = ccl::stream_t());
   
       template<class buffer_type,
                class = typename std::enable_if<ccl::is_native_type_supported<buffer_type>()>::type>
       coll_request_t alltoallv(const buffer_type* send_buf, const size_t* send_counts,
                                buffer_type* recv_buf, const size_t* recv_counts,
                                const ccl::coll_attr* attr = nullptr,
                                const ccl::stream_t& stream = ccl::stream_t());
       template<class buffer_container_type,
                class = typename std::enable_if<ccl::is_class_supported<buffer_container_type>()>::type>
       coll_request_t alltoallv(const buffer_container_type& send_buf, const size_t* send_counts,
                                buffer_container_type& recv_buf, const size_t* recv_counts,
                                const ccl::coll_attr* attr = nullptr,
                                const ccl::stream_t& stream = ccl::stream_t());
   
       void barrier(const ccl::stream_t& stream = ccl::stream_t());
   
       coll_request_t bcast(void* buf, size_t count,
                            ccl::datatype dtype,
                            size_t root,
                            const ccl::coll_attr* attr = nullptr,
                            const ccl::stream_t& stream = ccl::stream_t());
   
       template<class buffer_type,
                class = typename std::enable_if<ccl::is_native_type_supported<buffer_type>()>::type>
       coll_request_t bcast(buffer_type* buf, size_t count,
                            size_t root,
                            const ccl::coll_attr* attr = nullptr,
                            const ccl::stream_t& stream = ccl::stream_t());
   
       template<class buffer_container_type,
                class = typename std::enable_if<ccl::is_class_supported<buffer_container_type>()>::type>
       coll_request_t bcast(buffer_container_type& buf, size_t count,
                            size_t root,
                            const ccl::coll_attr* attr = nullptr,
                            const ccl::stream_t& stream = ccl::stream_t());
   
   
       coll_request_t reduce(const void* send_buf, void* recv_buf,
                             size_t count,
                             ccl::datatype dtype,
                             ccl::reduction reduction,
                             size_t root,
                             const ccl::coll_attr* attr = nullptr,
                             const ccl::stream_t& stream = ccl::stream_t());
   
       template<class buffer_type,
                class = typename std::enable_if<ccl::is_native_type_supported<buffer_type>()>::type>
       coll_request_t reduce(const buffer_type* send_buf, buffer_type* recv_buf,
                             size_t count,
                             ccl::reduction reduction,
                             size_t root,
                             const ccl::coll_attr* attr = nullptr,
                             const ccl::stream_t& stream = ccl::stream_t());
   
       template<class buffer_container_type,
                class = typename std::enable_if<ccl::is_class_supported<buffer_container_type>()>::type>
       coll_request_t reduce(const buffer_container_type& send_buf, buffer_container_type& recv_buf,
                             size_t count,
                             ccl::reduction reduction,
                             size_t root,
                             const ccl::coll_attr* attr = nullptr,
                             const ccl::stream_t& stream = ccl::stream_t());
   
   
       coll_request_t sparse_allreduce(const void* send_ind_buf, size_t send_ind_count,
                                       const void* send_val_buf, size_t send_val_count,
                                       void* recv_ind_buf, size_t recv_ind_count,
                                       void* recv_val_buf, size_t recv_val_count,
                                       ccl::datatype index_dtype,
                                       ccl::datatype value_dtype,
                                       ccl::reduction reduction,
                                       const ccl::coll_attr* attr = nullptr,
                                       const ccl::stream_t& stream = ccl::stream_t());
   
       template<class index_buffer_type,
                class value_buffer_type,
                class = typename std::enable_if<ccl::is_native_type_supported<value_buffer_type>()>::type>
       coll_request_t sparse_allreduce(const index_buffer_type* send_ind_buf, size_t send_ind_count,
                                       const value_buffer_type* send_val_buf, size_t send_val_count,
                                       index_buffer_type* recv_ind_buf, size_t recv_ind_count,
                                       value_buffer_type* recv_val_buf, size_t recv_val_count,
                                       ccl::reduction reduction,
                                       const ccl::coll_attr* attr = nullptr,
                                       const ccl::stream_t& stream = ccl::stream_t());
   
       template<class index_buffer_container_type,
                class value_buffer_container_type,
                class = typename std::enable_if<ccl::is_class_supported<value_buffer_container_type>()>::type>
       coll_request_t sparse_allreduce(const index_buffer_container_type& send_ind_buf, size_t send_ind_count,
                                       const value_buffer_container_type& send_val_buf, size_t send_val_count,
                                       index_buffer_container_type& recv_ind_buf, size_t recv_ind_count,
                                       value_buffer_container_type& recv_val_buf, size_t recv_val_count,
                                       ccl::reduction reduction,
                                       const ccl::coll_attr* attr = nullptr,
                                       const ccl::stream_t& stream = ccl::stream_t());
   
   private:
       friend class environment;
       friend class comm_group;
   
       explicit communicator(std::shared_ptr<communicator_interface> impl);
   
       std::shared_ptr<communicator_interface> pimpl;
   };
   }
   #ifdef MULTI_GPU_SUPPORT
       #include "ccl_gpu_modules.h"
       #include "gpu_communicator.hpp"
   #endif
