
.. _program_listing_file_include_gpu_communicator.hpp:

Program Listing for File gpu_communicator.hpp
=============================================

|exhale_lsh| :ref:`Return to documentation for file <file_include_gpu_communicator.hpp>` (``include\gpu_communicator.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   
   #ifdef MULTI_GPU_SUPPORT
   #ifndef CCL_PRODUCT_FULL
       #error "Do not include this file directly. Please include 'ccl_types.hpp'"
   #endif
   
   namespace ccl
   {
   struct gpu_comm_attr;
   struct communicator_interface;
   
   class comm_group
   {
   public:
       friend class environment;
   
       using device_context_native_reference_t = typename unified_device_context_type::native_reference_t;
       using device_context_native_const_reference_t = typename unified_device_context_type::native_const_reference_t;
       template <class DeviceType,
                 typename std::enable_if<std::is_class<typename std::remove_cv<DeviceType>::type>::value,
                                         int>::type = 0>
       communicator_t create_communicator(const DeviceType& device,
                                          device_comm_attr_t attr = device_comm_attr_t());
   
       device_comm_attr_t create_device_comm_attr();
   
       template <class DeviceType,
                 typename std::enable_if<not std::is_class<typename std::remove_cv<DeviceType>::type>::value,
                                         int>::type = 0>
       communicator_t create_communicator(DeviceType device_id,
                                          device_comm_attr_t attr = device_comm_attr_t());
   
       template<template<class...> class Container, class Type>
       std::vector<communicator_t> create_communicators(const Container<Type>& device_ids,
                                                        device_comm_attr_t attr = device_comm_attr_t());
   
       template<class InputIt>
       std::vector<communicator_t> create_communicators(InputIt first, InputIt last,
                                                        device_comm_attr_t attr = device_comm_attr_t());
   
       device_context_native_const_reference_t get_context() const;
   
   private:
       comm_group(ccl::shared_communicator_t comm, size_t current_device_group_size, size_t process_device_group_size);
       std::unique_ptr<gpu_comm_attr> pimpl;
   };
   
   #if DEPRECATED
   class communicator final
   {
   public:
   
       using device_native_reference_t = typename unified_device_type::native_reference_t;
   
       ~communicator();
   
       using coll_request_t = std::unique_ptr<request>;
   
       size_t rank() const;
   
       size_t size() const;
   
       device_native_reference_t get_device();
   
       bool is_ready() const;
   
       ccl::device_topology_type get_topology_type() const;
   
       template<class buffer_type,
                class = typename std::enable_if<ccl::is_native_type_supported<buffer_type>()>::type>
       coll_request_t allreduce(const buffer_type* send_buf,
                                buffer_type* recv_buf,
                                size_t count,
                                ccl::reduction reduction,
                                const ccl::coll_attr* attr,
                                const ccl::stream_t& stream);
   
   private:
       friend class environment;
       friend class comm_group;
   
       explicit communicator(std::shared_ptr<communicator_interface> impl);
   
       std::shared_ptr<communicator_interface> pimpl;
   
   };
   #endif //DEPRECATED
   }
   
   #endif //MULTI_GPU_SUPPORT
