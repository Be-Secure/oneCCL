.TH "OneCCLvars" 3 "Tue Jun 6 2023" "Version 2021.10" "Intel® oneAPI Collective Communications Library" \" -*- nroff -*-
.ad l
.nh
.SH NAME
OneCCLvars \- OneCCL Environment Variables
.SH SYNOPSIS
.br
.PP
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBCCL_LOG_LEVEL\fP"
.br
.RI "Set this environment variable to control logging level\&. "
.ti -1c
.RI "\fBCCL_WORKER_COUNT\fP"
.br
.RI "Set specify the number of oneCCL worker threads\&. "
.ti -1c
.RI "\fBCCL_WORKER_AFFINITY\fP"
.br
.RI "Set to specify cpu affinity for oneCCL worker threads\&. "
.ti -1c
.RI "\fBCCL_WORKER_MEM_AFFINITY\fP"
.br
.RI "Set to specify memory affinity for oneCCL worker threads\&. 
.br
\&. "
.ti -1c
.RI "\fBCCL_ATL_SHM\fP"
.br
.RI "Set this environment variable to enable the OFI shared memory provider for communication between ranks in the same node of host (CPU) buffers\&. 
.br
\&. "
.ti -1c
.RI "\fBCCL_ALLGATHERV\fP"
.br
.RI "Set allgatherv algorithm\&. "
.ti -1c
.RI "\fBCCL_ALLREDUCE\fP"
.br
.RI "Set allreduce algorithm\&. "
.ti -1c
.RI "\fBCCL_ALLTOALL\fP"
.br
.RI "Set alltoall algorithm\&. "
.ti -1c
.RI "\fBCCL_ALLTOALLV\fP"
.br
.RI "Set alltoallv algorithm\&. "
.ti -1c
.RI "\fBCCL_BARRIER\fP"
.br
.RI "Set barrier algorithm\&. "
.ti -1c
.RI "\fBCCL_BCAST\fP"
.br
.RI "Set broadcast algorithm\&. "
.ti -1c
.RI "\fBCCL_REDUCE\fP"
.br
.RI "Set reduce algorithm\&. "
.ti -1c
.RI "\fBCCL_REDUCE_SCATTER\fP"
.br
.RI "Set reduce-scatter algorithm\&. "
.ti -1c
.RI "\fBCCL_ALLGATHERV_SCALEOUT\fP"
.br
.RI "Set scaleout allgatherv algorithm\&. "
.ti -1c
.RI "\fBCCL_ALLREDUCE_SCALEOUT\fP"
.br
.RI "Set allreduce scaleout algorithm\&. "
.ti -1c
.RI "\fBCCL_ALLTOALL_SCALEOUT\fP"
.br
.RI "Set alltoall scaleout algorithm\&. "
.ti -1c
.RI "\fBCCL_ALLTOALLV_SCALEOUT\fP"
.br
.RI "Set alltoallv scaleout algorithm\&. "
.ti -1c
.RI "\fBCCL_REDUCE_SCALEOUT\fP"
.br
.RI "Set reduce scaleout algorithm\&. "
.ti -1c
.RI "\fBCCL_RS_CHUNK_COUNT\fP"
.br
.RI "Set to specify maximum number of chunks for reduce_scatter phase in ring allreduce\&. "
.ti -1c
.RI "\fBCCL_RS_MIN_CHUNK_SIZE\fP"
.br
.RI "Set to specify minimum number of bytes in chunk for reduce_scatter phase in ring allreduce\&. "
.ti -1c
.RI "\fBCCL_REDUCE_SCATTER_MONOLITHIC_KERNEL\fP"
.br
.RI "Set this environment variable to enable compute kernels for Allreduce, Reduce, and Reduce-Scatter collectives using device (GPU) buffers\&. "
.ti -1c
.RI "\fBCCL_ALLGATHERV_MONOLITHIC_PIPELINE_KERNEL\fP"
.br
.RI "Set this environment variable to enable compute kernels for Allgather collectives using device (GPU) buffers\&. "
.ti -1c
.RI "\fBCCL_ALLTOALLV_MONOLITHIC_KERNEL\fP"
.br
.RI "Set this environment variable to enable compute kernels for Alltoall and Alltoallv collectives using device (GPU) buffers\&. "
.ti -1c
.RI "\fBCCL_LOCAL_RANK\fP"
.br
.RI "Set this environment variable to specify the rank number of the current process in the local host\&. "
.ti -1c
.RI "\fBCCL_LOCAL_SIZE\fP"
.br
.RI "Set this environment variable to specify the total number of ranks on the local host\&. "
.ti -1c
.RI "\fBCCL_PROCESS_LAUNCHER\fP"
.br
.RI "Set this environment variable to specify the job launcher to use\&. "
.in -1c
.SH "Detailed Description"
.PP 

.SH "Variable Documentation"
.PP 
.SS "CCL_ALLGATHERV"

.PP
Set allgatherv algorithm\&. ALLGATHERV algorithms
.IP "\(bu" 2
direct Based on MPI_Iallgatherv
.IP "\(bu" 2
naive Send to all, receive from all
.IP "\(bu" 2
ring Alltoall-based algorithm
.IP "\(bu" 2
flat Alltoall-based algorithm
.IP "\(bu" 2
multi_bcast Series of broadcast operations with different root ranks
.IP "\(bu" 2
topo Topo scaleup algorithm
.PP
.PP
By-default: 'topo', if sycl and l0 are enabled, otherwise 'naive' for ofi or 'direct' for mpi; 'ring' used as fallback 
.SS "CCL_ALLGATHERV_MONOLITHIC_PIPELINE_KERNEL"

.PP
Set this environment variable to enable compute kernels for Allgather collectives using device (GPU) buffers\&. Syntax
.PP
CCL_ALLGATHERV_MONOLITHIC_PIPELINE_KERNEL='<value>' Arguments
.PP
'<value>' Description
.IP "\(bu" 2
1 Uses compute kernels to transfer data across GPUs for Allgather collective
.IP "\(bu" 2
0 Uses copy engines to transfer data across GPUs for Allgather collectives (default)
.PP
.PP
Description
.PP
Set this environment variable to enable compute kernels for Allgather collectives using device (GPU) buffers
.PP
By-default: '0' 
.SS "CCL_ALLGATHERV_SCALEOUT"

.PP
Set scaleout allgatherv algorithm\&. ALLGATHERV algorithms
.IP "\(bu" 2
direct Based on MPI_Iallgatherv
.IP "\(bu" 2
naive Send to all, receive from all
.IP "\(bu" 2
ring Alltoall-based algorithm
.IP "\(bu" 2
flat Alltoall-based algorithm
.IP "\(bu" 2
multi_bcast Series of broadcast operations with different root ranks
.PP
.PP
By-default: 'naive' for ofi or 'direct' for mpi; 'ring' used as fallback 
.SS "CCL_ALLREDUCE"

.PP
Set allreduce algorithm\&. ALLREDUCE algorithms
.IP "\(bu" 2
direct Based on MPI_Iallreduce
.IP "\(bu" 2
rabenseifner Rabenseifner’s algorithm
.IP "\(bu" 2
nreduce May be beneficial for imbalanced workloads
.IP "\(bu" 2
ring Reduce_scatter + allgather ring\&. Use CCL_RS_CHUNK_COUNT and CCL_RS_MIN_CHUNK_SIZE to control pipelining on reduce_scatter phase\&.
.IP "\(bu" 2
double_tree Double-tree algorithm
.IP "\(bu" 2
recursive_doubling Recursive doubling algorithm
.IP "\(bu" 2
2d Two-dimensional algorithm (reduce_scatter + allreduce + allgather)\&. Only available for Host (CPU) buffers\&.
.IP "\(bu" 2
topo Topo scaleup algorithm (available if sycl and l0 are enabled)
.PP
.PP
By-default: 'topo', if sycl and l0 are enable, otherwise 'ring' 
.SS "CCL_ALLREDUCE_SCALEOUT"

.PP
Set allreduce scaleout algorithm\&. ALLREDUCE algorithms
.IP "\(bu" 2
direct Based on MPI_Iallreduce
.IP "\(bu" 2
rabenseifner Rabenseifner’s algorithm
.IP "\(bu" 2
nreduce May be beneficial for imbalanced workloads
.IP "\(bu" 2
ring Reduce_scatter + allgather ring\&. Use CCL_RS_CHUNK_COUNT and CCL_RS_MIN_CHUNK_SIZE to control pipelining on reduce_scatter phase\&.
.IP "\(bu" 2
double_tree Double-tree algorithm
.IP "\(bu" 2
recursive_doubling Recursive doubling algorithm
.IP "\(bu" 2
2d Two-dimensional algorithm (reduce_scatter + allreduce + allgather)\&. Only available for Host (CPU) buffers\&.
.PP
.PP
By-default: 'ring' 
.SS "CCL_ALLTOALL"

.PP
Set alltoall algorithm\&. ALLTOALLV algorithms
.IP "\(bu" 2
direct Based on MPI_Ialltoallv
.IP "\(bu" 2
naive Send to all, receive from all
.IP "\(bu" 2
scatter Scatter-based algorithm
.IP "\(bu" 2
topo Topo scaleup algorithm (available if sycl and l0 are enabled)
.PP
.PP
By-default: 'topo', if sycl and l0 are enable, otherwise 'scatter' 
.SS "CCL_ALLTOALL_SCALEOUT"

.PP
Set alltoall scaleout algorithm\&. ALLTOALL algorithms
.IP "\(bu" 2
direct Based on MPI_Ialltoall
.IP "\(bu" 2
naive Send to all, receive from all
.IP "\(bu" 2
scatter Scatter-based algorithm
.PP
.PP
By-default: 'scatter' 
.SS "CCL_ALLTOALLV"

.PP
Set alltoallv algorithm\&. ALLTOALLV algorithms
.IP "\(bu" 2
direct Based on MPI_Ialltoallv
.IP "\(bu" 2
naive Send to all, receive from all
.IP "\(bu" 2
topo Topo scaleup algorithm (available if sycl and l0 are enabled)
.PP
.PP
By-default: 'topo', if sycl and l0 are enable, otherwise 'scatter' 
.SS "CCL_ALLTOALLV_MONOLITHIC_KERNEL"

.PP
Set this environment variable to enable compute kernels for Alltoall and Alltoallv collectives using device (GPU) buffers\&. Syntax
.PP
CCL_ALLTOALLV_MONOLITHIC_KERNEL='<value>'
.PP
Arguments
.PP
'<value>' Description
.IP "\(bu" 2
1 Uses compute kernels to transfer data across GPUs for AlltoAll and Alltoallv collectives (default)
.IP "\(bu" 2
0 Uses copy engines to transfer data across GPUs for AlltoAll and Alltoallv collectives
.PP
.PP
Description
.PP
Set this environment variable to enable compute kernels for Alltoall and Alltoallv collectives using device (GPU) buffers
.PP
By-default: '1' 
.SS "CCL_ALLTOALLV_SCALEOUT"

.PP
Set alltoallv scaleout algorithm\&. ALLTOALLV algorithms
.IP "\(bu" 2
direct Based on MPI_Ialltoallv
.IP "\(bu" 2
naive Send to all, receive from all
.IP "\(bu" 2
scatter Scatter-based algorithm
.PP
.PP
By-default: 'scatter' 
.SS "CCL_ATL_SHM"

.PP
Set this environment variable to enable the OFI shared memory provider for communication between ranks in the same node of host (CPU) buffers\&. 
.br
\&. Syntax 
.br
CCL_ATL_SHM='<value>'
.br

.br
Arguments
.br
'<value>' Description
.br
.IP "\(bu" 2
0 Disables OFI shared memory provider (default)\&.
.br

.IP "\(bu" 2
1 Enables OFI shared memory provider\&.
.br

.br
Description
.br
 Set this environment variable to enable the OFI shared memory provider for communication between ranks in the same node of host (CPU) buffers\&.
.PP
.PP
By-default: '0' 
.SS "CCL_BARRIER"

.PP
Set barrier algorithm\&. BARRIER algorithms
.IP "\(bu" 2
direct Based on MPI_Ibarrier
.IP "\(bu" 2
ring Ring-based algorithm
.PP
.PP
Note: BARRIER does not support the CCL_BARRIER_SCALEOUT environment variable\&. To change the algorithm for scaleout, use CCL_BARRIER\&.
.PP
By-default: 'direct' 
.SS "CCL_BCAST"

.PP
Set broadcast algorithm\&. BCAST algorithms
.IP "\(bu" 2
direc Based on MPI_Ibcast
.IP "\(bu" 2
ring Ring
.IP "\(bu" 2
double_tree Double-tree algorithm
.IP "\(bu" 2
naive Send to all from root rank
.PP
.PP
Note: BCAST algorithm does not support yet the CCL_BCAST_SCALEOUT environment variable\&. To change the algorithm for BCAST, use CCL_BCAST\&.
.PP
By-default: 'direct' 
.SS "CCL_LOCAL_RANK"

.PP
Set this environment variable to specify the rank number of the current process in the local host\&. Syntax
.PP
CCL_LOCAL_RANK='<value>'
.PP
Arguments
.PP
'<value>' Description
.IP "\(bu" 2
RANK Rank number of the current process in the local host
.PP
.PP
Description
.PP
Set this environment variable to specify the rank number of the current process in the local host
.PP
By-default: N/A; job/process launcher (CCL_PROCESS_LAUNCHER) needs to be used if variable not specified 
.SS "CCL_LOCAL_SIZE"

.PP
Set this environment variable to specify the total number of ranks on the local host\&. Syntax
.PP
CCL_LOCAL_SIZE='<value>'
.PP
Arguments
.PP
'<value>' Description
.IP "\(bu" 2
SIZE Total number of ranks on the local host\&.
.PP
.PP
Description
.PP
Set this environment variable to specify the total number of ranks on the local host
.PP
By-default: N/A; job/process launcher (CCL_PROCESS_LAUNCHER) needs to be used if variable not specified 
.SS "CCL_LOG_LEVEL"

.PP
Set this environment variable to control logging level\&. The \fCCCL_LOG_LEVEL\fP environment variable can be set to control the level of detail in the logging output generated by the CCL library\&.
.PP
'<value>': 'error', 'warn', 'info', 'debug', 'trace'
.PP
By-default: 'warn' 
.SS "CCL_PROCESS_LAUNCHER"

.PP
Set this environment variable to specify the job launcher to use\&. Syntax
.PP
CCL_PROCESS_LAUNCHER='<value>'
.PP
Arguments
.PP
'<value>' Description
.IP "\(bu" 2
hydra Uses the MPI hydra job launcher (default)
.IP "\(bu" 2
torch Uses torch job launcher
.IP "\(bu" 2
pmix It is used with the PALS job launcher which uses the pmix API, so your mpiexec command should look something like this: CCL_PROCESS_LAUNCHER=pmix CCL_ATL_TRANSPORT=mpi mpiexec -np 2 -ppn 2 --pmi=pmix \&.\&.\&.
.IP "\(bu" 2
none No Job launcher is used\&. In this case, the user needs to specify the values for CCL_LOCAL_SIZE and CCL_LOCAL_RANK
.PP
.PP
Description
.PP
Set this environment variable to specify the job launcher to use\&.
.PP
By-default: 'hydra' 
.SS "CCL_REDUCE"

.PP
Set reduce algorithm\&. REDUCE algorithms
.IP "\(bu" 2
direct Based on MPI_Ireduce
.IP "\(bu" 2
rabenseifner Rabenseifner’s algorithm
.IP "\(bu" 2
ring Ring algorithm
.IP "\(bu" 2
tree Tree algorithm
.IP "\(bu" 2
double_tree Double-tree algorithm
.IP "\(bu" 2
topo Topo scaleup algorithm (available if sycl and l0 are enabled)
.PP
.PP
By-default: 'topo' if sycl and l0 are enabled, otherwise tree for ofi transport or direct for mpi 
.SS "CCL_REDUCE_SCALEOUT"

.PP
Set reduce scaleout algorithm\&. REDUCE algorithms
.IP "\(bu" 2
direct Based on MPI_Ireduce
.IP "\(bu" 2
rabenseifner Rabenseifner’s algorithm
.IP "\(bu" 2
ring Ring algorithm
.IP "\(bu" 2
tree Tree algorithm
.IP "\(bu" 2
double_tree Double-tree algorithm
.PP
.PP
By-default: 'double_tree' 
.SS "CCL_REDUCE_SCATTER"

.PP
Set reduce-scatter algorithm\&. REDUCE_SCATTER algorithms
.IP "\(bu" 2
direct Based on MPI_Ireduce_scatter_block
.IP "\(bu" 2
ring Use CCL_RS_CHUNK_COUNT and CCL_RS_MIN_CHUNK_SIZE to control pipelining\&.
.IP "\(bu" 2
topo Topo algorithm (available if sycl and l0 are enabled, scaleup only)
.PP
.PP
Note: REDUCE_SCATTER algorithm does not support yet the CCL_REDUCE_SCATTER_SCALEOUT environment variable\&. To change the algorithm for REDUCE_SCATTER scaleout, use CCL_REDUCE_SCATTER\&.
.PP
By-default: 'direct' 
.SS "CCL_REDUCE_SCATTER_MONOLITHIC_KERNEL"

.PP
Set this environment variable to enable compute kernels for Allreduce, Reduce, and Reduce-Scatter collectives using device (GPU) buffers\&. Syntax CCL_REDUCE_SCATTER_MONOLITHIC_KERNEL='<value>'
.PP
Arguments
.PP
'<value>' Description
.IP "\(bu" 2
1 Uses compute kernels to transfer data across GPUs for Allreduce, Reduce, and Reduce-Scatter collectives
.IP "\(bu" 2
0 Uses copy engines to transfer data across GPUs for Allreduce, Reduce, and Reduce-Scatter collectives (default)\&.
.PP
.PP
Description
.PP
Set this environment variable to enable compute kernels for Allreduce, Reduce, and Reduce-Scatter collectives using device (GPU) buffers
.PP
By-default: '0' 
.SS "CCL_RS_CHUNK_COUNT"

.PP
Set to specify maximum number of chunks for reduce_scatter phase in ring allreduce\&. '<count>' - Maximum number of chunks for reduce_scatter phase in ring allreduce
.PP
By-default: '1' 
.SS "CCL_RS_MIN_CHUNK_SIZE"

.PP
Set to specify minimum number of bytes in chunk for reduce_scatter phase in ring allreduce\&. '<size>' - Minimum number of bytes in chunk for reduce_scatter phase in ring allreduce\&. Affects actual value of CCL_RS_CHUNK_COUNT\&.
.PP
By-default: '65536' 
.SS "CCL_WORKER_AFFINITY"

.PP
Set to specify cpu affinity for oneCCL worker threads\&. '<value>': 'auto', '<cpulist>': 
.br
 'auto' - Workers are automatically pinned to last cores of pin domain\&. Pin domain depends from process launcher\&. If mpirun from oneCCL package is used then pin domain is MPI process pin domain\&. Otherwise, pin domain is all cores on the node\&. 
.br
 '<cpulist>' - A comma-separated list of core numbers and/or ranges of core numbers for all local workers, one number per worker\&. The i-th local worker is pinned to the i-th core in the list\&. For example 'a','b'-'c'defines list of cores contaning core with number 'a' and range of cores with numbers from 'b' to 'c'\&. The number should not exceed the number of cores available on the system\&.
.PP
By-default: 'not-specified' 
.SS "CCL_WORKER_COUNT"

.PP
Set specify the number of oneCCL worker threads\&. '<value>' - The number of worker threads for oneCCL rank
.PP
By-default: '1' 
.SS "CCL_WORKER_MEM_AFFINITY"

.PP
Set to specify memory affinity for oneCCL worker threads\&. 
.br
\&. '<nodelist>' : 
.br
 'auto' - Workers are automatically pinned to NUMA nodes that correspond to CPU affinity of workers\&. 
.br
 A comma-separated list of NUMA node numbers for all local workers, one number per worker\&. The i-th local worker is pinned to the i-th NUMA node in the list\&. The number should not exceed the number of NUMA nodes available on the system\&.
.PP
By-default: 'not-specified' 
.SH "Author"
.PP 
Generated automatically by Doxygen for Intel® oneAPI Collective Communications Library from the source code\&.
.TH "ExpOneCCLvars" 3 "Tue Jun 6 2023" "Version 2021.10" "Intel® oneAPI Collective Communications Library" \" -*- nroff -*-
.ad l
.nh
.SH NAME
ExpOneCCLvars \- Experimental OneCCL Environment Variables
.PP
 \- Experimental OneCCL Environment Variables Functionality of these variables has not been (fully) tested and, therefore, cannot be supported nor guaranteed\&.  

.SH SYNOPSIS
.br
.PP
.SS "Variables"

.in +1c
.ti -1c
.RI "\fBCCL_REDUCE_SCATTER_MONOLITHIC_PIPELINE_KERNEL\fP"
.br
.RI "Set to specify monolithic pipeline approach for reduce_scatter phase in allreduceand reduce collectives\&. "
.ti -1c
.RI "\fBCCL_ZE_IPC_EXCHANGE\fP"
.br
.RI "Set to specify the mechanism to use for Level Zero IPC exchange\&. "
.ti -1c
.RI "\fBCCL_ZE_DRM_BDF_SUPPORT\fP"
.br
.RI "Use bdf support for mapping logical to physical devices\&. "
.ti -1c
.RI "\fBCCL_REDUCE_SCATTER_FALLBACK_ALGO\fP"
.br
.RI "Use the fallback algorithm for reduce_scatter\&. "
.ti -1c
.RI "\fBCCL_ZE_AUTO_TUNE_PORTS\fP"
.br
.RI "Automatically tune algorithm protocols based on port count\&. "
.in -1c
.SH "Detailed Description"
.PP 
Experimental OneCCL Environment Variables Functionality of these variables has not been (fully) tested and, therefore, cannot be supported nor guaranteed\&. 


.SH "Variable Documentation"
.PP 
.SS "CCL_REDUCE_SCATTER_FALLBACK_ALGO"

.PP
Use the fallback algorithm for reduce_scatter\&. The fallback algorithm performs a full allreduce and then copies a subset of its output to the recv buffer\&. Currently, the fallback algorithm is used for scaleout whereas scaleup uses optimized algorithm\&.
.PP
'<value>' : '0', '1'
.PP
By-default: '0' 
.SS "CCL_REDUCE_SCATTER_MONOLITHIC_PIPELINE_KERNEL"

.PP
Set to specify monolithic pipeline approach for reduce_scatter phase in allreduceand reduce collectives\&. This enviroment variable has the advantage of forming a seamless pipeline that conceals the data transfer time across MDFI\&. This way, a process reads the data from its peer tile on the same GPU, performs the reduction, and writes to a temporary buffer located on a different GPU\&. This modification will cover the time for transferring the data through XeLinks during the reduce-scatter phase in allreduce and reduce collectives\&.
.PP
'<value>' : '0', '1'
.PP
By-default: '1' 
.SS "CCL_ZE_AUTO_TUNE_PORTS"

.PP
Automatically tune algorithm protocols based on port count\&. Use number of ports to detect the 12 ports system and use write protocols on such systems for collectives\&. Users can disable this automatic detection and select the protocols manually\&.
.PP
'<value>' : '0', '1'
.PP
By-default: '1' 
.SS "CCL_ZE_DRM_BDF_SUPPORT"

.PP
Use bdf support for mapping logical to physical devices\&. To obtain the physical device id based on the bdf, we need get and then parse the bdf values\&. Then using those values we can identify the particular device by referencing the appropriate fields in a pci configuration space for pci devices\&.to utilize bdf for the purpose of mapping logical devices to their corresponding physical devices\&.
.PP
'<value>' : '0', '1'
.PP
By-default: '1' 
.SS "CCL_ZE_IPC_EXCHANGE"

.PP
Set to specify the mechanism to use for Level Zero IPC exchange\&. 
.br
 'drmfd' - Uses a the DRM mechanism for Level Zero IPC exchange\&. This is an experimental mechanism that is used with OS kernels previous to SP4\&. To use the DRM mechanism, the libdrm and drm headers must be available on a system\&. 
.br
 'pidfd' - Uses pidfd mechanism for Level Zero IPC exchange\&. It requires OS kernel SP4 or above as it requires Linux 5\&.6 kernel or above 
.br
 'sockets' - Uses socket mechanism for Level Zero IPC exchange\&. It is usually slower than the other two mechanisms, but can be used for debugging as it is usually available on most systems
.PP
'<value>': 'drmfd', 'pidfd', 'sockets'
.PP
By-default: 'drmfd' 
.SH "Author"
.PP 
Generated automatically by Doxygen for Intel® oneAPI Collective Communications Library from the source code\&.
